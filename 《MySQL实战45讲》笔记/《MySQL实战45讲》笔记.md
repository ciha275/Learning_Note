# 《MySQL实战45讲》笔记

## 第1讲 基础架构：一条SQL查询语句如何执行

- MySQL整体分两层：
  - server层：连接器、查询缓存、分析器、优化器、执行器等。所有跨引擎的功能在这实现。
  - 存储引擎层：数据的存储、提取。架构模式为插件式，支持InnoDB、M有ISAM、Memory等多个存储引擎。

- ![](G:\change_job\笔记\《MySQL实战45讲》笔记\图\MySQL架构.jpg)
- 连接器：管理连接，权限验证
  - 权限验证成功了，才有后续
  - 连接上分短连接、长连接。尽量使用长连接，但会导致内存使用的累积，占用内存涨得特别快。
  - 解决长连接方案：（1）定期断开长连接；（2）MySQL5.7及更新，执行`mysql_reset_connection`重新初始化连接资源，但不会重连和权限验证。
- 查询缓存：命中直接返回结果
  - 但不建议用，因为一旦对表更新，查询缓存就清空，所以查询缓存易失效，不建议使用。
- 分析器：词法分析，语法分析
  - 词法分析，识别出关键字，并据此识别其他字符串，让字符串有意义
  - 语法分析，根据词法分析结果，根据语法规则分析是否符合MySQL语法
- 优化器：执行计划生成，索引选择
  - 同一个语句可能有不同执行顺序，带来不同效率，优化器选出效率最优的
- 执行器：操作引擎，返回结果
  - 根据优化器的执行计划，开始执行。但首先判断有没有执行的权限。
- 小结：连接器让客户端和MySQL连起来，分析器知晓做什么，优化器确定怎么做，执行器开始做。

## 第2讲 日志系统：一条SQL更新语句如何执行

- 两个日志模块：**redo log（重做日志）**、**binlog（归档日志）**。

### redo log：是InnoDB引擎特有的日志

- 《45讲》中以“粉板”比喻redo log，个人理解，就是把更新操作给集中起来，然后再统一的写入MySQL中。降低了一条条更新到MySQL中的IO成本、查找成本。
- 即 WAL技术，全称 Write-Ahead Logging，关键点就是**先写日志，再写磁盘**。
- redo log的大小是有限的，例如“一组4个文件，每个文件1GB，共4GB可记录”。从头开始写，写道末尾又返回。如下图所示
- ![](G:\change_job\笔记\《MySQL实战45讲》笔记\图\redo log的文件结构.jpg)

- **write pos是当前记录的位置**， 一边写一边后移， 写到第3号文件末尾后就回到0号文件开头。
- **checkpoint是当前要擦除的位置**， 也是往后推移并且循环的， 擦除记录前要把记录更新到数据文件。

- write pos与checkpoint之间（write的后面check的前面）就是空闲区域。一旦write pos追上checkpoint，不能执行新的更新操作，得停下来擦除一些内容（即写磁盘），让checkpoint向前推进一些。
- **crash-safe：**有了redo log，InnoDB就可以保证数据库发生异常重启后，之前提交的记录都不会丢失。

### binlog：是Server层的日志

- 仅使用binlog没有crash-safe能力。
- **redo log与binlog的区别：**
  - redo log是InnoDB引擎特有的；binlog是MySQL的Server层实现的， 所有引擎都可以使用。
  - redo log是物理日志， 记录的是“在某个数据页上做了什么修改”； binlog是逻辑日志， 记录的是这个语句的原始逻辑， 比如“给ID=2这一行的c字段加1 ”。
  - redo log是循环写的， 空间固定会用完； binlog是可以追加写入的。 “追加写”是指binlog文件写到一定大小后会切换到下一个， 并不会覆盖以前的日志。

- `UPDATE T SET c=c+1 WHERE ID=2;` 这条UPDATE语句的执行过程如下图，浅色框表示在InnoDB内部执行，深色框表示在执行器内执行：
- ![](G:\change_job\笔记\《MySQL实战45讲》笔记\图\UPDATE语句执行过程.jpg)
- **关于如何使用binlog回复数据：：**
  - 当需要恢复到指定的某一秒时，比如某天下午两点发现中午十二点有一次误删表，需要找回数据， 那你可以这么做：
    - 首先，找到最近的一次全量备份，如果你运气好，可能就是昨天晚上的一个备份，从这个备份恢复到临时库；
    - 然后，从备份的时间点开始，将备份的binlog依次取出来，重放到中午误删表之前的那个时刻。
  - 这样你的临时库就跟误删之前的线上库一样了，然后你可以把表数据从临时库取出来， 按需要恢复到线上库去。

### 为什么redo log需要两段式提交

- 是跨系统维持数据逻辑一致性时常用的方案。
- 考虑反证：如果redo log就一次性提交，那么可能是：redo log先提交binlog后提交，或者binlog先提交redo log后提交。这两种情况如果执行时中间出现异常，即只有先提交的提交了。这个前提下再考虑数据恢复的场景：
  - redo log先提交binlog后提交：此时binlog里没有记录相应的语句，当利用binlog恢复时，就会少一条语句，导致恢复的数据与原库的值不一致。
  - binlog先提交redo log后提交：此时binlog里记录一条语句，但是这条语句是并没有执行成功的，当利用binlog恢复时，就会多一条语句，导致恢复的数据与原库的值不一致。
