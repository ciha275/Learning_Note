# 《MySQL实战45讲》笔记

## 第1讲 基础架构：一条SQL查询语句如何执行

- MySQL整体分两层：
  - server层：连接器、查询缓存、分析器、优化器、执行器等。所有跨引擎的功能在这实现。
  - 存储引擎层：数据的存储、提取。架构模式为插件式，支持InnoDB、M有ISAM、Memory等多个存储引擎。

- ![](G:\change_job\笔记\《MySQL实战45讲》笔记\图\01-MySQL架构.jpg)
- 连接器：管理连接，权限验证
  - 权限验证成功了，才有后续
  - 连接上分短连接、长连接。尽量使用长连接，但会导致内存使用的累积，占用内存涨得特别快。
  - 解决长连接方案：（1）定期断开长连接；（2）MySQL5.7及更新，执行`mysql_reset_connection`重新初始化连接资源，但不会重连和权限验证。
- 查询缓存：命中直接返回结果
  - 但不建议用，因为一旦对表更新，查询缓存就清空，所以查询缓存易失效，不建议使用。
- 分析器：词法分析，语法分析
  - 词法分析，识别出关键字，并据此识别其他字符串，让字符串有意义
  - 语法分析，根据词法分析结果，根据语法规则分析是否符合MySQL语法
- 优化器：执行计划生成，索引选择
  - 同一个语句可能有不同执行顺序，带来不同效率，优化器选出效率最优的
- 执行器：操作引擎，返回结果
  - 根据优化器的执行计划，开始执行。但首先判断有没有执行的权限。
- 小结：连接器让客户端和MySQL连起来，分析器知晓做什么，优化器确定怎么做，执行器开始做。

## 第2讲 日志系统：一条SQL更新语句如何执行

- 两个日志模块：**redo log（重做日志）**、**binlog（归档日志）**。

### redo log：是InnoDB引擎特有的日志

- 《45讲》中以“粉板”比喻redo log，个人理解，就是把更新操作给集中起来，然后再统一的写入MySQL中。降低了一条条更新到MySQL中的IO成本、查找成本。
- 即 WAL技术，全称 Write-Ahead Logging，关键点就是**先写日志，再写磁盘**。
- redo log的大小是有限的，例如“一组4个文件，每个文件1GB，共4GB可记录”。从头开始写，写道末尾又返回。如下图所示
- ![](G:\change_job\笔记\《MySQL实战45讲》笔记\图\02-redo log的文件结构.jpg)

- **write pos是当前记录的位置**， 一边写一边后移， 写到第3号文件末尾后就回到0号文件开头。
- **checkpoint是当前要擦除的位置**， 也是往后推移并且循环的， 擦除记录前要把记录更新到数据文件。

- write pos与checkpoint之间（write的后面check的前面）就是空闲区域。一旦write pos追上checkpoint，不能执行新的更新操作，得停下来擦除一些内容（即写磁盘），让checkpoint向前推进一些。
- **crash-safe：**有了redo log，InnoDB就可以保证数据库发生异常重启后，之前提交的记录都不会丢失。

### binlog：是Server层的日志

- 仅使用binlog没有crash-safe能力。
- **redo log与binlog的区别：**
  - redo log是InnoDB引擎特有的；binlog是MySQL的Server层实现的， 所有引擎都可以使用。
  - redo log是物理日志， 记录的是“在某个数据页上做了什么修改”； binlog是逻辑日志， 记录的是这个语句的原始逻辑， 比如“给ID=2这一行的c字段加1 ”。
  - redo log是循环写的， 空间固定会用完； binlog是可以追加写入的。 “追加写”是指binlog文件写到一定大小后会切换到下一个， 并不会覆盖以前的日志。

- `UPDATE T SET c=c+1 WHERE ID=2;` 这条UPDATE语句的执行过程如下图，浅色框表示在InnoDB内部执行，深色框表示在执行器内执行：
- ![](G:\change_job\笔记\《MySQL实战45讲》笔记\图\02-UPDATE语句执行过程.jpg)
- **关于如何使用binlog回复数据：：**
  - 当需要恢复到指定的某一秒时，比如某天下午两点发现中午十二点有一次误删表，需要找回数据， 那你可以这么做：
    - 首先，找到最近的一次全量备份，如果你运气好，可能就是昨天晚上的一个备份，从这个备份恢复到临时库；
    - 然后，从备份的时间点开始，将备份的binlog依次取出来，重放到中午误删表之前的那个时刻。
  - 这样你的临时库就跟误删之前的线上库一样了，然后你可以把表数据从临时库取出来， 按需要恢复到线上库去。

### 为什么redo log需要两段式提交

- 是跨系统维持数据逻辑一致性时常用的方案。
- 考虑反证：如果redo log就一次性提交，那么可能是：redo log先提交binlog后提交，或者binlog先提交redo log后提交。这两种情况如果执行时中间出现异常，即只有先提交的提交了。这个前提下再考虑数据恢复的场景：
  - redo log先提交binlog后提交：此时binlog里没有记录相应的语句，当利用binlog恢复时，就会少一条语句，导致恢复的数据与原库的值不一致。
  - binlog先提交redo log后提交：此时binlog里记录一条语句，但是这条语句是并没有执行成功的，当利用binlog恢复时，就会多一条语句，导致恢复的数据与原库的值不一致。

## 第3讲 事务隔离：为什么你改了我还看不见

- 首先关于事务：
  - **由引擎层实现及支持**
  - **四要素**：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）

### 隔离级别

- 为什么有“隔离级别”？
  - 因为当多个事务同时执行时，可能出现**脏读（dirty read）**、**不可重复读（nonrepeatable read）**、**幻读（phantom read）**的问题。采用隔离级别就是为了解决这些问题。
- 四种隔离级别：读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）、串行化（serializable）。
- 以下两个事务按时间顺序执行

- ![](G:\change_job\笔记\《MySQL实战45讲》笔记\图\03-事务隔离级别演示.jpg)

- **读未提交（read uncommitted）：**一个事务还没提交时，它做的变更就能被别的事务看到。
  - `V1=2、V2=2、V3=2`，这很好理解，因为只要B的变更出现A就能看到了。
- **读提交（read committed）：**一个事务提交之后，它做的变更才会被其他事务看到。
  - `V1=1、V2=2、V3=2`，等到了B提交之后A才能看到变动，所以V1时还是1。
- **可重复读（repeatable read）：**一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。
  - `V1=1、V2=1、V3=2`，因为要保证事务执行期间看到数据是一致的，而V1、V2都在A事务内所以一致。
- **串行化（serializable）：**对于同一行记录，“写”会加“写锁” ，“读” 会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。
  - `V1=1、V2=1、V3=2`，与可重复读的结果一样，但原因不同。这里是因为，A先执行，到B时B是被锁住的没有执行，直到A提交结束了A事务，B才执行。所以V1、V2都是1。

### 事务隔离的实现

- 在实现上，数据库里面会创建一个**视图**，访问的时候以视图的逻辑结果为准。
  - 在”可重复读“隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。
  - 在“读提交”隔离级别下，这个视图是在每个SQL语句开始执行的时候创建的。
  - **值得注意的是：**“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；而“串行化”隔离级别下直接用加锁的方式来避免并行访问。
- 设置隔离级别：将启动参数transaction-isolation的值设置成READ-COMMITTED。你可以用show variables来查看当前的值。

- 对于”可重复读“，每个事务启动时会创建视图。那么对于以下示例，将一个值从1依次改为2、3、4，回滚日志里有类似下面的记录，而查询这条记录时，不同时刻启动的事务会有不同的read-view，也如下图所示

  - ![](G:\change_job\笔记\《MySQL实战45讲》笔记\图\03-事务隔离的实现.jpg)

  - 在视图A、B、C里此记录的值分别为1、2、4，同一条记录在系统中可以存在多个版本，这就是数据库的多版本并发控制（MVCC）。

- 而对于read-view A，要得到1，就得把当前值依次按图中回滚操作得到。**因此，对于回滚日志，当系统里没有比这个回滚日志更早的read-view时，该回滚日志才会被删除。**

- **为什么建议尽量不用长事务**

  - 长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。

### 事务的启动方式

- 建议不使用长事务，但有时长事务是误用导致的，这就涉及到了事务的启动方式：
  - **显式的：**显式启动事务语句，begin 或 start transaction。配套的提交语句是commit，回滚语句是rollback。
  - **隐式的：**set autocommit=0，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个select语句，这个事务就启动了，而且并不会自动提交。这个事务持续存在直到你主动执行commit 或 rollback 语句，或者断开连接。

- **隐式启动事务可能带来误用长事务，因此建议：**
  - set autocommit =1，通过显式语句启动事务；
  - 对于频繁使用事务的情形，commit后又重新begin，增加交互次数，因此建议使用`commit work and chain`替代commit，减少语句的交互次数。
- 关于 **commit work and chain** ：
  - 在autocommit为1的情况下，如果执行commit work and chain，则是提交事务并自动启动下一个事务，这样也省去了再次执行begin语句的开销。
  - 同时带来的好处是从程序开发的角度明确地知道每个语句是否处于事务中。
